<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul>
    <li>001</li>
    <li>002</li>
    <li>003</li>
</ul>
<script>
    //闭包
    //一个外部函数，里面有一个内部函数，内部函数调用了外部函数的局部变量
    //当外部函数执行完成后，在外部函数释放之时，局部变量不会被释放，因为内部函数一直在使用

    var aLi = document.getElementsByTagName('li');


    //原生js 错误输出索引值的方法
//    for(var i = 0 ;i<aLi.length;i++){
//        aLi[i].onclick = function () {
//            console.log(i);   //输出全是3
//            //因为for循环是页面一开始就执行的，i的值执行之后就变成3
//        }
//    }

            //原生js 正确的输出索引值的做法 把i的值方放到数组的索引值里
//    for(var i=0;i<aLi.length;i++){
//        aLi[i].index = i;           //用i来记录索引值
//        aLi[i].onclick = function () {
//            console.log(this.index);   //用来记录当前的索引，输出的是当前的索引
//        }
//    }

                //闭包的方法
    for(var i= 0;i<aLi.length;i++){
        (function (index) {
            aLi[index].onclick=function () {
                console.log(index);
            }
        })(i)
    }

    //1.var有变量提升，而let没有变量提升
    console.log(a); //undefined   相当于在输出a之前的生成一个 var a； 的语句
    var a =10;
//    console.log(b);   //not define 所以没有变量提升
    let b =10;

    //2.var 可以重复命名，而let没有
    var a = 20 ;
    console.log(a);   //20
//    let b = 20 ;   //出错
    //3.临时失效区（暂时性死区）
//    var c =10;
//    function fn() {
//        console.log(c);//not define
//        let c = 10 ;      //不能使用fn外定义的c ，只能用let定义的c，而且let没有变量提升
//    }
//    fn();

    //4.块作用域 （let const）
    for (let  i = 0 ;i<3 ;i++){         //let i z只能在这个块里生效
        console.log(i);
    }
    console.log(i);   //在块外失效
</script>
</body>
</html>